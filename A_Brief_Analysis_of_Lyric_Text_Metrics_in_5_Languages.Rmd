---
title: "A Brief Analysis of Lyric Metrics"
author: "Julia Stelman"
date: "3/22/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r, message=FALSE, warning=FALSE}
library(quanteda)
library(tidyverse)
library(nnet)
library(DescTools)
library(caret)
library(dplyr)
library(stringi)

AFsongDF <- read.csv("AFsongDF.csv", row.names=1)

dat <- na.exclude(AFsongDF[,c(-5,-16:-12,-23)])
dat$sid <- as.character(dat$sid)

# files borrowed from Dr David Brown's Text Analysis class at Carnegie Mellon University, Fall 2019
# forked from his course github page
source("https://github.com/stelmanj/textstat_tools/blob/master/functions/keyness_functions.R")
source("https://github.com/stelmanj/textstat_tools/blob/master/functions/dispersion_functions.R")

library(readtext)
library(tidyverse)
library(corpus)
```

# Introduction

In this mini analysis of lyric data, I explore a few features of lyric exerpts from 100 songs in 5 different languages. I compare 20 songs written in each language. I want to know if a language spoken across a wider geographical area, in turn, constitutes a language with a broader collection of regional vocabularies, and, in turn, leads to a sample of songs whose joint lyrics utilize a larger set of words than a language spoken across a smaller geographical range does.

In other words, do the songs written by, say, Spanish speaking artists vary more, lyrically, than songs written by, say, Indonesian artists? It would make sense, as Spanish is spoken all over the world, heightening the potential that this language has been split into different dialects by divergent evolution. Meanwhile, Indonesian is only spoken, officially, in Indonesia, a region that, based on the small size of its land area and longitudal range, doesn't look like it provides the Indondesian language as much potential for forming individual dialects. 

The following two languages make up the *widely spoken* group:

* English (en)

* Spanish (es)

The following three languages make up the *not widely spoken* group:

* Indonesian (id)

* Dutch (nl)

* Swahili (sw)

The distinction between the first and second groups is decided by whether a language is an official national language on at least three continents. 

# Summarizing the Data

I've used the natural language processing package $\verb|quanteda|$ to calculate the following metrics for the first few lines of lyrics in each of the 100 sampled songs. (20 songs were randomly sampled from each of the 5 languages.)

* Types --> distinct words

* Tokens --> words

* Type/Token Ratio (TTR)

```{r, message=FALSE, warning=FALSE}
# get the encoding types of each lyric excerpt.
stri_lang_enc = vapply(1:nrow(dat), function(x){
  stri_enc_detect(
    dat$lyrics[x], filter_angle_brackets = F
    )[[1]][c('Language','Encoding','Confidence')][1,] %>%
    unlist()},
  FUN.VALUE = c('Language','Encoding','Confidence')) %>% t() %>%
  as.data.frame()

# Make the text doc df for corpus analysis

lyrics_df2 <- dat %>%
  select(doc_id = sid, text = lyrics, lang) %>%
  cbind(stri_lang_enc) %>%
  mutate_if(is.factor, as.character) %>%
  # get rid of non-ISO encodings
  filter(Encoding %in% c("ISO-8859-1","ISO-8859-9","ISO-8859-2")) %>%
  # if lang.detect said English but R said something else, get rid of it
  dplyr::filter(ifelse(lang != "en", T, ifelse(lang == Language, T, F)))

langs <- data.frame(lang = c('en', 'es', 'id', 'sw', 'nl'), stringsAsFactors = F)

# only use the languages in the 5 specified
lyrics_df2 <- lyrics_df2 %>% 
  inner_join(langs)

# clean up
rm(langs)

# take a smaller, evenly dispersed sample
set.seed(10)
## take an equal random sample from all five languages of interest
En_ids <- subset(x=lyrics_df2,subset = lang == 'en')$doc_id
## n = 20 because there are exactly 22 songs in Dutch, the language of the 5 with the fewest songs
En_ids <- sample(En_ids,20)
eS_ids <- subset(x=lyrics_df2,subset = lang == 'es')$doc_id
eS_ids <- sample(eS_ids,20)
Id_ids <- subset(x=lyrics_df2,subset = lang == 'id')$doc_id
Id_ids <- sample(Id_ids,20)
Nl_ids <- subset(x=lyrics_df2,subset = lang == 'nl')$doc_id
Nl_ids <- sample(Nl_ids,20)
sW_ids <- subset(x=lyrics_df2,subset = lang == 'sw')$doc_id
sW_ids <- sample(sW_ids,20)

# replace a misclassified song
En_ids_all <- subset(x=lyrics_df2,subset = lang == 'en')$doc_id
En_ids[which(En_ids == "720ZYTSr4vSqcFYq2CTJKN")] <-
  sample(En_ids_all[-which(En_ids_all %in% En_ids)],1)
rm(En_ids_all)
# replace another misclassified song
Id_ids_all <- subset(x=lyrics_df2,subset = lang == 'id')$doc_id
Id_ids[which(Id_ids == "7mrxKs2fqNiKBE8zePEP2l")] <-
  sample(Id_ids_all[-which(Id_ids_all %in% Id_ids)],1)
rm(Id_ids_all)

# make a data frame from the songs selected
esinw_df <- subset(x = lyrics_df2, select = names(lyrics_df2),
                   subset = doc_id %in% c(
                      En_ids, eS_ids, Id_ids, Nl_ids, sW_ids))
```

I summarized these as by-language averages in the table below. 

```{r, message=FALSE, warning=FALSE}

# create a corpus object
lyrics_corpus <- corpus(esinw_df)

# fetch a summary of the corpus composition
lyrics_sum <- summary(lyrics_corpus, tolower = T, n = 902) %>% select(- Sentences)

# Corpus composition table
lyrics_sum3ds <- lyrics_sum %>% 
  mutate(Text = as.character(Text)) %>%
  mutate(TTR = Types/Tokens) %>% 
  mutate(Language = lang)

# get all the averages we might want for the overall total
lyrics_sum_cct_avg <- lyrics_sum3ds %>% 
  summarise("Texts" = length(Text),
            "Avg Tokens per Lyric Excerpt" = round(mean(Tokens)),
            "Tokens in Total" = sum(Tokens),
            "Avg Types per Lyric Excerpt" = round(mean(Types),2), 
            "Avg Type/Token Ratio (TTR)" = round(mean(TTR),3)) %>% 
  mutate(Language = "all") %>%
  select(Language, Texts, `Tokens in Total`, `Avg Tokens per Lyric Excerpt`, `Avg Types per Lyric Excerpt`, `Avg Type/Token Ratio (TTR)`)

# get the ones for each language
lyrics_sum_cct_va <- lyrics_sum3ds %>% group_by(Language) %>% 
  summarise("Texts" = length(Text),
            "Avg Tokens per Lyric Excerpt" = round(mean(Tokens)),
            "Tokens in Total" = sum(Tokens), 
            "Avg Types per Lyric Excerpt" = round(mean(Types),2), 
            "Avg Type/Token Ratio (TTR)" = round(mean(TTR),3)) %>%  ungroup() %>%
  select(Language, Texts, `Tokens in Total`, `Avg Tokens per Lyric Excerpt`, `Avg Types per Lyric Excerpt`, `Avg Type/Token Ratio (TTR)`)

# bind them together
lyrics_sum_cct_va <- rbind(lyrics_sum_cct_va, lyrics_sum_cct_avg)

# now that we have that, lets choose just the parts we want to show in output this time
lyrics_sum_cct_simp <- lyrics_sum_cct_va  %>%
  filter(Language %in% c("en","es","id","nl","sw")) %>%
  select(Language, `Avg Types per Lyric Excerpt`, `Avg Tokens per Lyric Excerpt`, `Avg Type/Token Ratio (TTR)`)

# Tada!
knitr::kable(lyrics_sum_cct_simp)
```

After concatenating together the 20-song random sample of lyric excerpts from each language, I re-calculated the metrics again treating the combination of all sampled lyrics from one language as if it were from one song. (The code for how I did this is in the Appendix) They are shown in the table below. It's this information that will give me insight on what I'm really looking for. 

```{r, message=FALSE, warning=FALSE}
# concatenate songs of the same language together
esinw_df_combined <- esinw_df %>% group_by(lang) %>%
  summarise("text" = paste(text, collapse = " ")) %>%
  select(doc_id = lang, text)

# And create a new corpus object based on this
lyrics_corpus_esinw <- corpus(esinw_df_combined)

# fetch a summary of the corpus composition
lyrics_sum_esinw <- summary(lyrics_corpus_esinw, tolower = T) %>% select(- Sentences)

# Choose the metrics that we want to output in the table
lyrics_sum3ds_esinw <- lyrics_sum_esinw %>% 
  mutate(Text = as.character(Text),
         TTR = round(Types/Tokens,3)) %>%
  rename(Language = Text)

# output the table
knitr::kable(lyrics_sum3ds_esinw)
```

# Exploratory Data Analysis

Let's take a look at some histograms of token counts to get a better look.

```{r}
par(mfrow = c(2,3))
lyrics_sum$Tokens[lyrics_sum$lang == "en"] %>% 
  hist(main = "Tokens: English")
lyrics_sum$Tokens[lyrics_sum$lang == "es"] %>% 
  hist(main = "Tokens: Spanish")
lyrics_sum$Tokens[lyrics_sum$lang == "id"] %>% 
  hist(main = "Tokens: Indonesian")
lyrics_sum$Tokens[lyrics_sum$lang == "nl"] %>% 
  hist(main = "Tokens: Dutch")
lyrics_sum$Tokens[lyrics_sum$lang == "sw"] %>% 
  hist(main = "Tokens: Swahili")
```

No large gaps and no big outliers. Based on the histogram, it seems like Indonesian song lyric exerpts run small. Indonesian's token count range is about half that of other languages.

Let's also do the same thing for type counts, just for good measure.

```{r}
par(mfrow = c(2,3))
lyrics_sum$Types[lyrics_sum$lang == "en"] %>% 
  hist(main = "Types: English")
lyrics_sum$Types[lyrics_sum$lang == "es"] %>% 
  hist(main = "Types: Spanish")
lyrics_sum$Types[lyrics_sum$lang == "id"] %>% 
  hist(main = "Types: Indonesian")
lyrics_sum$Types[lyrics_sum$lang == "nl"] %>% 
  hist(main = "Types: Dutch")
lyrics_sum$Types[lyrics_sum$lang == "sw"] %>% 
  hist(main = "Types: Swahili")
```

Frankly, all ten of these histograms are far from the normal distribution, but, for the extent of their use in this brief analysis, the data here will work fine. As a final check, let's plot type count against token count in scatter plots.

```{r}
par(mfrow = c(2,3))

# plot the Types vs Tokens scatterplot for each language
# include each one's Rsquared in the plot title
# draw each LSRL in red

# English
lyrics_sum[lyrics_sum$lang == "en",c('Tokens','Types')] %>% 
  plot(main = paste(
    "English: R^2 =",
    # calculate the R squared and paste it into the plot title
    summary(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="en",]))$r.squared %>%
      round(2)))
abline(
  # plot the LSRL in red
  coef(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="en",])),
  col = "red")

# Spanish
lyrics_sum[lyrics_sum$lang == "es",c('Tokens','Types')] %>% 
  plot(main = paste(
    "Spanish: R^2 =",
    # calculate the R squared and paste it into the plot title
    summary(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="es",]))$r.squared %>%
      round(2)))
abline(
  # plot the LSRL in red
  coef(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="es",])),
  col = "red")

# Indonesian
lyrics_sum[lyrics_sum$lang == "id",c('Tokens','Types')] %>% 
  plot(main = paste(
    "Indonesian: R^2 =",
    # calculate the R squared and paste it into the plot title
    summary(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="id",]))$r.squared %>%
      round(2)))
abline(
  # plot the LSRL in red
  coef(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="id",])),
  col = "red")

# Dutch
lyrics_sum[lyrics_sum$lang == "nl",c('Tokens','Types')] %>% 
  plot(main = paste(
    "Dutch: R^2 =",
    # calculate the R squared and paste it into the plot title
    summary(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="nl",]))$r.squared %>%
      round(2)))
abline(
  # plot the LSRL in red
  coef(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="nl",])),
  col = "red")

# Swahili
lyrics_sum[lyrics_sum$lang == "sw",c('Tokens','Types')] %>% 
  plot(main = paste(
    "Swahili: R^2 =",
    # calculate the R squared and paste it into the plot title
    summary(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="sw",]))$r.squared %>%
      round(2)))
abline(
  # plot the LSRL in red
  coef(lm(Types~Tokens, data=lyrics_sum[lyrics_sum$lang=="sw",])),
  col = "red")
```

While these distributions aren't ideal, we just need evidence that there isn't some big bad underlying problem that we should worry is potentially corrupting the patterns that we are seeing. And based on the histograms and scatter plots above, I'm convinced. Let's continue.

# Results

In the plot below, the widely spoken languages are drawn in red. The numbers used to make these plots are all taken from the tables in the **Summarizing the Data** section.

```{r, message=FALSE, warning=FALSE}
# set up the ploting region
par(mfrow = c(2,3))
# plot each of the three metrics from the first table and then each from the second preserving order
# widely spoken langauges in red, not-widely spoken languages in black
#x axis is the going to be factors, the five languages
# y axes will tell us the values of the each metric pertaining to each language

# first the averages
plot(x = factor(lyrics_sum_cct_simp$Language),
     y = lyrics_sum_cct_simp$`Avg Types per Lyric Excerpt`, 
     border = "white",
     xlab = "Language", 
     ylab = "Avg Types per Lyric Excerpt",
     main = "1: Avg Types per Excerpt"
     ); points(x = factor(lyrics_sum_cct_simp$Language),
       y = lyrics_sum_cct_simp$`Avg Types per Lyric Excerpt`, 
       col = c("red","red","black","black","black")
       ); abline(v = 2.5,lty = 3)
plot(x = factor(lyrics_sum_cct_simp$Language),
     y = lyrics_sum_cct_simp$`Avg Tokens per Lyric Excerpt`, 
     border = "white",
     xlab = "Language", 
     ylab = "Avg Tokens per Lyric Excerpt",
     main = "2: Avg Tokens per Excerpt"
     ); points(x = factor(lyrics_sum_cct_simp$Language),
       y = lyrics_sum_cct_simp$`Avg Tokens per Lyric Excerpt`, 
       col = c("red","red","black","black","black")
       ); abline(v = 2.5,lty = 3)
plot(x = factor(lyrics_sum_cct_simp$Language),
     y = lyrics_sum_cct_simp$`Avg Type/Token Ratio (TTR)`, 
     border = "white",
     xlab = "Language", 
     ylab = "Avg Type/Token Ratio (TTR)",
     main = "3: Avg TTR per Exerpt"
     ); points(x = factor(lyrics_sum_cct_simp$Language),
       y = lyrics_sum_cct_simp$`Avg Type/Token Ratio (TTR)`, 
       col = c("red","red","black","black","black")
       ); abline(v = 2.5,lty = 3)

# then the totals (the concatenated versions)
plot(x = factor(lyrics_sum3ds_esinw$Language),
     y = lyrics_sum3ds_esinw$Types, 
     border = "white",
     xlab = "Language", 
     ylab = "Total Types per Language",
     main = "4: Types per Language"
     ); points(x = factor(lyrics_sum3ds_esinw$Language),
       y = lyrics_sum3ds_esinw$Types, 
       col = c("red","red","black","black","black")
       ); abline(v = 2.5,lty = 3)
plot(x = factor(lyrics_sum3ds_esinw$Language),
     y = lyrics_sum3ds_esinw$Tokens, 
     border = "white",
     xlab = "Language", 
     ylab = "Total Tokens per Language",
     main = "5: Tokens per Language"
     ); points(x = factor(lyrics_sum3ds_esinw$Language),
       y = lyrics_sum3ds_esinw$Tokens, 
       col = c("red","red","black","black","black")
       ); abline(v = 2.5,lty = 3)
plot(x = factor(lyrics_sum3ds_esinw$Language),
     y = lyrics_sum3ds_esinw$TTR, 
     border = "white",
     xlab = "Language", 
     ylab = "Type/Token Ratio (TTR)",
     main = "6: TTR for Language"
     ); points(x = factor(lyrics_sum3ds_esinw$Language),
       y = lyrics_sum3ds_esinw$TTR, 
       col = c("red","red","black","black","black")
       ); abline(v = 2.5,lty = 3)
```

Based on Plot 6, the words used in different Swahili songs have the least in common out of any of the five languages-- and by a long shot! 

Based on Plot 2, it would seem that the Indonesian songs, on average, have rather few words, therefore inflating the Type/Token Ratio of individual Indonesian songs (Plot 3). When the Indonesian lyrics are pooled, the effect on TTR (Plot 6) of low token count (Plot 5) is countered by the effect of low type count (Plot 4). 

Notice that, in Plots 5 and 6, Spanish has about 20 fewer types (3% fewer) and around 470 fewer tokens (15% fewer) than English, while Dutch has about 60 more types (10% more) and about 30 more tokens (1% more) than English. Still, in Plot 6, both Spanish and Dutch have a TTR that's about 0.02 to 0.03 units, or 10 to 15 percent, higher than English's TTR. In Plot 6, Spanish's TTR rose above English's TTR purely by leveraging a lower token count in the denominator. Meanwhile, Dutch's TTR had no help from *its* denominator; Dutch's TTR passed English's TTR entirely by type count superiority. 

Type/Token Ratio is a measure that is often criticized for how easily it can be manipulated by corpus size, aka token count. It's likely that this quality of TTR is a key cause for Indonesian's differing behaviors in the Plots 3 and 6. 


# Discussion

It looks like songs written in "not widely spoken" languages might actually vary more, lyrically, than songs written in widely spoken languages, which is the absolute opposite of what I hypothesized earlier. More analysis (and actual statistical tests) would have to be done in order for any real conclusions to be drawn. Still, I've thought of a few reasons for why this pattern might have occured. 

* Pop music has a more unified set of common words compared to many other genres. As opposed to artists who write lyrics in English or Spanish, artists who write songs in Swahili have a smaller target market. As a result, they may be more inclined to write song lyrics that they are individually inspired to write rather than song lyrics that will get them into the Top 40.

* The language detector is not perfect. Some songs get misclassified. Being as there was a small pool of Swahili songs to sample from in the first place, a few mistakes would make a bigger difference in Swahili than in English and Spanish.

* My reasoning was incorrect: a larger, and more geographically diverse, set of speakers is *not* affiliated with a larger number of dialects.

The behavior of Swahili was especially interesting to me. To get further insight, I contacted my cousin who lives in Tanzania. He told me that it's a trade language that unifies several countries on the East African Coast, but that, in each one of the countries where Swahili is spoken, it's a little bit different. And furthermore, the Swahili spoken around the coast differs slightly from the Swahili spoken in the interior. So maybe dialectal diversity *is* associated with some of the variation between different Swahili songs.

# Acknowledgements

Thank you to Spotify, Musixmatch, Everynoise.com, and lang-detect for the help I got from your libraries, websites, and APIs in the data collection and cleaning phase of this project, which I did in Python. 

Also thank you to the R libraries $\verb|quanteda|$, $\verb|tidyverse|$, $\verb|DescTools|$, $\verb|caret|$, $\verb|dplyr|$, $\verb|stringi|$, and $\verb|knitr|$.


